# Пакет java.util.concurrent
Данный пакет включает в себя набор классов, которые ориентированы на работу с несколькими потоками.

Функционально пакет можно разделить на несколько частей:
1. коллекции и мапы для работы с многопоточных средах
2. очереди (в том числе блокирующие)
3. утилиты для синхронизации потоков
4. классы для создания пулов потоков
5. альтернативные механизмы синхронизации (замена synchronized, wait, notify, notifyAll)
6. классы с поддержкой атомарных операций над примитивами и ссылками

#### Коллекции и мапы
1. допускают одновременное чтение и внесение изменений разными потоками
2. не вызывают исключение ConcurrentModificationException при удалении в цикле
3. коллекции предоставляют метод addIfAbsent(obj), который позволяет добавить элемент, в случае отсутствия данной записи, причем сделать это атомарно.
4. мапы предоставляют метод putIfAbsent(key, value), который позволяет добавить в Map ключ-значение, в случае отсутствия данной записи, причем сделать это атомарно.

CopyOnWriteArrayList, CopyOnWriteArraySet используют алгоритм CopyOnWrite,
что предполагает создание копии внутреннего массива на каждое изменение коллекции (add, set, remove).

ConcurrentSkipListSet хранит элементы в отсортированном виде, использует алгоритм SkipList - набор связных списков

ConcurrentHashMap использует несколько (по умолчанию 16) сегментов, каждый сегмент представляет собой HashMap.
При работе с данной мапой сначала определяется сегмент, в который необходимо добавить/удалить/изменить пару ключ-значение,
после чего данный сегмент блокируется, остальные сегменты остаются доступны.

ConcurrentNavigableMap обеспечивает возможность получения элементов отображения относительно других элементов (наименьший/наибольший ключ, первый/последний элементы и тд)

ConcurrentSkipListMap хранит элементы в отсортированном по ключам порядке, использует алгоритм SkipList - набор связных списков

#### Очереди (в том числе блокирующие)

Блокирующие очереди используются, если необходимо приостановить работу потока, если не соблюдены определенные условия, например, очередь переполнена,
в очереди нет элементов и тп
1. реализуют интерфейсы BlockingQueue, BlockingDeque, TransferQueue.
2. реализация BlockingQueue гарантирует, что любая попытка извлечь элемент (метод take) из пустой очереди заблокирует вызывающий поток до тех пор,
   пока не появится доступный элемент, а любая попытка вставить элемент (метод put) в заполненную очередь заблокирует вызывающий поток до тех пор,
   пока не освободится место для нового элемента.
3. реализация интерфейса TransferQueue позволяет при добавлении элемента в очередь заблокировать вставляющий поток до тех пор,
   пока другой поток не заберет элемент из очереди.

ArrayBlockingQueue реализует кольцевой буфер. Параметр fair в конструкторе позволяет управлять соблюдением очередности ожидающих и извлекающих потоков.
Размер очереди задается в конструкторе и не меняется.

SynchronousQueue - очередь, в которой каждая операция добавления должна ждать соответствующей операции удаления в другом потоке и наоборот (принцип «один вошел, один вышел»).

LinkedTransferQueue позволяет при добавлении элемента в очередь (метод transfer) заблокировать вставляющий поток до тех пор, пока другой поток не заберет элемент из очереди.
Дает гарантию, что элемент будет получен из очереди. Размер очереди можно задать в конструкторе, по умолчанию - максимальный int

DelayQueue позволяет извлекать элементы только после некоторой задержки, определенной в каждом элементе, те позволяет выполнять задачи по расписанию.

LinkedBlockingQueue (более высокую производительность и более высокий расход памяти) - очередь на связанных узлах.

LinkedBlockingDeque — двунаправленная блокирующая очередь на связанных узлах.